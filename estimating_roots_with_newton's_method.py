# -*- coding: utf-8 -*-
"""Estimating Roots With Newton's Method

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dZS-pGxCOgXLrkImpKep1qRf_90-_p67
"""



import math
import sympy as smp
import sys
import matplotlib.pyplot as plt

x=smp.Symbol('x')
print ("Please enter a function in the form F(x) = function (E.g F(x) = x**2-3*x)")
user_function_str = input()
while True:
  if user_function_str.startswith("F(x) ="):
    # Remove the "F(x) =" part and any leading/trailing whitespace
    user_function_str= user_function_str[6:].strip()
  else:
    # If it doesn't start with "F(x) =", assume the user just entered the function expression
    user_function_str = user_function_str.strip()
  invalid_char_found = False
  for character in user_function_str:
    if character.isalpha():
      if character != "x" and character != "e":
        print ("Not a valid function. Please try again.")
        user_function_str = input()
        invalid_char_found = True
        break
      else:
        pass
  if not invalid_char_found:
    try:
      function_sympy_expression = smp.parse_expr(user_function_str)
      break # Exit loop if parsing is successful
    except smp.SympifyError:
      print ("That is not a valid function. Please try again.")
      user_function_str = input() # Ask for input again if parsing failed
''
# Calculate the derivative of the function using sympy
sympy_derivative = smp.diff(function_sympy_expression, x)

def function(val):
  # Substitute the numerical value 'val' into the symbolic function expression
  return function_sympy_expression.subs(x, val)

def FPrime(val):
  # Substitute the numerical value 'val' into the symbolic derivative expression
  return sympy_derivative.subs(x, val)

def NewtonsMethod(i):
  # Evaluate the derivative at the current point
  f_prime_val = FPrime(i)

  if f_prime_val == 0:
    print(f"Derivative is zero at x = {i}. Cannot continue.")
    sys.exit()
  # Apply the Newton's method formula
  return i - function(i) / f_prime_val

print ("How many iterations of Newton's Method would you like to perform? (Up to 1,000)")
iterations_str = input() # Use a different variable name for the string input

# Loop to get valid integer input for iterations
while True:
  try:
    iterations = int(iterations_str)
    if 0 < iterations <= 1000: # Check if
      break # Exit loop if valid
    else:
      print ("That is not a valid number (must be between 1 and 1,000). Please try again.")
      iterations_str = input() # Ask for input again if not valid
  except ValueError:
    print ("That is not a valid number. Please try again.")
    iterations_str = input() # Ask for input again if not a number

print ("Please enter your initial guess.")
guess_str = input()

# Loop to get valid float input for the initial guess
while True:
  try:
    guess = float(guess_str) # Convert the guess_str to a float
    break # Exit loop if valid
  except ValueError:
    print ("That is not a valid number. Please try again.")
    guess_str = input() # Ask for input again if not a number

# Initialize list to store iteration results
my_list = [guess] # Start the list with the initial guess

# Perform Newton's method iterations
# We iterate 'iterations' times, so the list will have iterations + 1 elements
for counter in range(iterations):
  next_approximation = NewtonsMethod(my_list[-1])
  my_list.append(next_approximation)

# Print final approximation
print(f"\nAfter {iterations} iterations, the approximation of the root is: {my_list[-1]}")
plt.plot(my_list)
plt.title("Convergence of Newton's Method")
plt.xlabel("Iteration")
plt.ylabel("Approximation")
plt.grid(True)
plt.show()